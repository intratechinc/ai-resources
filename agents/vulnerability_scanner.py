#!/usr/bin/env python3
"""
Vulnerability Scanner Agent for Intratech Cybersecurity Suite
Handles vulnerability scanning, CVE analysis, and security weakness detection
"""

import json
import subprocess
import re
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
import ipaddress
import socket

from .base_agent import BaseAgent, TaskPriority
from config import Config
from database import VulnerabilityAssessment, SeverityLevel

class VulnerabilityAgent(BaseAgent):
    """
    Specialized agent for vulnerability scanning and assessment
    """
    
    def __init__(self):
        super().__init__(
            name="Vulnerability Scanner Agent",
            description="Performs vulnerability scanning and security assessments",
            capabilities=[
                "Network vulnerability scanning",
                "CVE analysis and lookup",
                "Security weakness detection",
                "Port scanning and service enumeration",
                "Web application vulnerability assessment",
                "Configuration analysis",
                "Patch management assessment",
                "Risk prioritization",
                "Remediation recommendations",
                "Compliance vulnerability checks"
            ]
        )
        
        # Vulnerability scanning profiles
        self.scan_profiles = {
            'basic': {
                'description': 'Basic vulnerability scan',
                'techniques': ['port_scan', 'service_detection', 'basic_vulns'],
                'timeout': 300
            },
            'comprehensive': {
                'description': 'Comprehensive vulnerability assessment',
                'techniques': ['port_scan', 'service_detection', 'vuln_scan', 'web_scan', 'config_check'],
                'timeout': 1800
            },
            'stealth': {
                'description': 'Stealth vulnerability scan',
                'techniques': ['stealth_scan', 'service_detection', 'targeted_vulns'],
                'timeout': 600
            }
        }
        
        # CVE database (simplified)
        self.cve_database = {
            'CVE-2023-1234': {
                'severity': 'high',
                'cvss_score': 8.5,
                'description': 'Remote code execution vulnerability',
                'affected_systems': ['Apache', 'Nginx'],
                'solution': 'Update to latest version'
            },
            'CVE-2023-5678': {
                'severity': 'critical',
                'cvss_score': 9.8,
                'description': 'SQL injection vulnerability',
                'affected_systems': ['MySQL', 'PostgreSQL'],
                'solution': 'Apply security patches'
            }
        }
        
        # Common vulnerability patterns
        self.vuln_patterns = {
            'ssh_weak_config': {
                'name': 'SSH Weak Configuration',
                'severity': 'medium',
                'description': 'SSH service allows weak authentication methods',
                'remediation': 'Disable password authentication, use key-based auth'
            },
            'open_database': {
                'name': 'Exposed Database Service',
                'severity': 'high',
                'description': 'Database service exposed to network',
                'remediation': 'Restrict database access, use firewall rules'
            },
            'default_credentials': {
                'name': 'Default Credentials',
                'severity': 'critical',
                'description': 'Service using default credentials',
                'remediation': 'Change default credentials immediately'
            }
        }
        
        # Scanning results cache
        self.scan_cache = {}
        
        self.logger.info("Vulnerability Scanner Agent initialized")
    
    def get_system_prompt(self) -> str:
        """Get the system prompt for vulnerability scanning"""
        return """You are a Vulnerability Scanner Agent specializing in cybersecurity vulnerability assessment. Your expertise includes:

**Core Capabilities:**
â€¢ Network vulnerability scanning and assessment
â€¢ CVE (Common Vulnerabilities and Exposures) analysis
â€¢ Security weakness identification and classification
â€¢ Risk assessment and prioritization
â€¢ Remediation guidance and recommendations
â€¢ Compliance-based vulnerability checks

**Scanning Approaches:**
â€¢ Network-based vulnerability scanning
â€¢ Web application security assessment
â€¢ Configuration security review
â€¢ Patch management evaluation
â€¢ Service enumeration and analysis

**Analysis Framework:**
1. Target identification and reconnaissance
2. Service discovery and enumeration
3. Vulnerability detection and validation
4. Risk assessment and CVSS scoring
5. Prioritization based on exploitability
6. Remediation recommendations
7. Compliance gap analysis

**Response Format:**
â€¢ Provide detailed vulnerability reports
â€¢ Include CVSS scores and severity levels
â€¢ Explain potential impact and exploitability
â€¢ Offer specific remediation steps
â€¢ Prioritize findings by risk level
â€¢ Suggest preventive measures

Always follow responsible disclosure practices and ensure scanning activities are authorized."""
    
    def process_message(self, message: str, context: Dict[str, Any] = None) -> str:
        """Process vulnerability scanning related messages"""
        try:
            # Analyze the message for scanning requests
            request_type = self._determine_scan_type(message)
            
            if request_type == 'network_scan':
                return self._handle_network_scan_request(message)
            elif request_type == 'cve_lookup':
                return self._handle_cve_lookup(message)
            elif request_type == 'web_scan':
                return self._handle_web_scan_request(message)
            elif request_type == 'config_check':
                return self._handle_config_check(message)
            elif request_type == 'patch_assessment':
                return self._handle_patch_assessment(message)
            else:
                return self._handle_general_vuln_query(message)
                
        except Exception as e:
            self.logger.error(f"Error processing vulnerability message: {str(e)}")
            return f"I encountered an error while processing your vulnerability request: {str(e)}"
    
    def _determine_scan_type(self, message: str) -> str:
        """Determine the type of vulnerability scan needed"""
        message_lower = message.lower()
        
        if any(word in message_lower for word in ['network scan', 'port scan', 'nmap']):
            return 'network_scan'
        elif any(word in message_lower for word in ['cve', 'vulnerability lookup', 'exploit']):
            return 'cve_lookup'
        elif any(word in message_lower for word in ['web scan', 'web app', 'application']):
            return 'web_scan'
        elif any(word in message_lower for word in ['config', 'configuration', 'hardening']):
            return 'config_check'
        elif any(word in message_lower for word in ['patch', 'update', 'upgrade']):
            return 'patch_assessment'
        else:
            return 'general_vulnerability'
    
    def _handle_network_scan_request(self, message: str) -> str:
        """Handle network vulnerability scan requests"""
        # Extract target from message
        targets = self._extract_targets(message)
        
        if not targets:
            return "I need a target to scan. Please provide an IP address, IP range, or hostname."
        
        response = "ðŸ” **Network Vulnerability Scan**\n\n"
        
        for target in targets:
            response += f"**Target: {target}**\n"
            
            # Validate target
            if not self._validate_target(target):
                response += f"âŒ Invalid target: {target}\n\n"
                continue
            
            # Perform scan simulation
            scan_results = self._simulate_network_scan(target)
            
            response += f"**Scan Results:**\n"
            response += f"â€¢ Open Ports: {len(scan_results['open_ports'])}\n"
            response += f"â€¢ Services Detected: {len(scan_results['services'])}\n"
            response += f"â€¢ Vulnerabilities Found: {len(scan_results['vulnerabilities'])}\n\n"
            
            # Show vulnerabilities
            if scan_results['vulnerabilities']:
                response += "**Vulnerabilities Detected:**\n"
                for vuln in scan_results['vulnerabilities']:
                    response += f"â€¢ {vuln['name']} - {vuln['severity'].upper()}\n"
                    response += f"  â””â”€ {vuln['description']}\n"
                response += "\n"
            
            # Show recommendations
            response += "**Recommendations:**\n"
            for rec in scan_results['recommendations']:
                response += f"â€¢ {rec}\n"
            
            response += "\n"
        
        return response
    
    def _extract_targets(self, message: str) -> List[str]:
        """Extract scan targets from message"""
        targets = []
        
        # IP addresses
        ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
        ips = re.findall(ip_pattern, message)
        targets.extend(ips)
        
        # IP ranges
        cidr_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}\b'
        cidrs = re.findall(cidr_pattern, message)
        targets.extend(cidrs)
        
        # Hostnames
        hostname_pattern = r'\b[a-zA-Z0-9][a-zA-Z0-9-]*\.[a-zA-Z]{2,}\b'
        hostnames = re.findall(hostname_pattern, message)
        targets.extend(hostnames)
        
        return list(set(targets))
    
    def _validate_target(self, target: str) -> bool:
        """Validate if target is safe to scan"""
        try:
            # Check if it's an IP address
            if '/' in target:  # CIDR notation
                network = ipaddress.ip_network(target, strict=False)
                return True
            else:
                ip = ipaddress.ip_address(target)
                # Don't scan private networks unless explicitly allowed
                if ip.is_private:
                    return True  # For demo purposes
                return True
        except ValueError:
            # Might be a hostname
            try:
                socket.gethostbyname(target)
                return True
            except socket.gaierror:
                return False
        
        return False
    
    def _simulate_network_scan(self, target: str) -> Dict[str, Any]:
        """Simulate a network vulnerability scan"""
        # This would perform actual scanning in a real implementation
        scan_results = {
            'target': target,
            'scan_time': datetime.now().isoformat(),
            'open_ports': [22, 80, 443, 3306],
            'services': [
                {'port': 22, 'service': 'ssh', 'version': 'OpenSSH 7.4'},
                {'port': 80, 'service': 'http', 'version': 'Apache 2.4.6'},
                {'port': 443, 'service': 'https', 'version': 'Apache 2.4.6'},
                {'port': 3306, 'service': 'mysql', 'version': 'MySQL 5.7.25'}
            ],
            'vulnerabilities': [
                {
                    'name': 'SSH Weak Configuration',
                    'severity': 'medium',
                    'description': 'SSH allows password authentication',
                    'port': 22,
                    'cve': None
                },
                {
                    'name': 'Exposed Database Service',
                    'severity': 'high',
                    'description': 'MySQL database exposed to network',
                    'port': 3306,
                    'cve': None
                }
            ],
            'recommendations': [
                'Disable SSH password authentication',
                'Restrict MySQL access to localhost only',
                'Update Apache to latest version',
                'Implement proper firewall rules'
            ]
        }
        
        return scan_results
    
    def _handle_cve_lookup(self, message: str) -> str:
        """Handle CVE lookup requests"""
        # Extract CVE IDs from message
        cve_pattern = r'CVE-\d{4}-\d{4,7}'
        cves = re.findall(cve_pattern, message, re.IGNORECASE)
        
        if not cves:
            return "I didn't find any CVE IDs in your message. Please provide CVE IDs in the format CVE-YYYY-NNNN."
        
        response = "ðŸ“‹ **CVE Analysis Results**\n\n"
        
        for cve in cves:
            cve_upper = cve.upper()
            response += f"**{cve_upper}**\n"
            
            if cve_upper in self.cve_database:
                info = self.cve_database[cve_upper]
                response += f"â€¢ **Severity:** {info['severity'].upper()}\n"
                response += f"â€¢ **CVSS Score:** {info['cvss_score']}\n"
                response += f"â€¢ **Description:** {info['description']}\n"
                response += f"â€¢ **Affected Systems:** {', '.join(info['affected_systems'])}\n"
                response += f"â€¢ **Solution:** {info['solution']}\n\n"
            else:
                response += f"â€¢ **Status:** Not found in local database\n"
                response += f"â€¢ **Recommendation:** Check official CVE database\n\n"
        
        return response
    
    def _handle_web_scan_request(self, message: str) -> str:
        """Handle web application scan requests"""
        # Extract URLs from message
        url_pattern = r'https?://[^\s]+'
        urls = re.findall(url_pattern, message)
        
        if not urls:
            return "I need a URL to scan. Please provide a web application URL."
        
        response = "ðŸŒ **Web Application Vulnerability Scan**\n\n"
        
        for url in urls:
            response += f"**Target: {url}**\n\n"
            
            # Simulate web scan
            web_scan_results = self._simulate_web_scan(url)
            
            response += f"**Scan Summary:**\n"
            response += f"â€¢ Total Checks: {web_scan_results['total_checks']}\n"
            response += f"â€¢ Vulnerabilities Found: {len(web_scan_results['vulnerabilities'])}\n"
            response += f"â€¢ Risk Level: {web_scan_results['risk_level']}\n\n"
            
            if web_scan_results['vulnerabilities']:
                response += "**Vulnerabilities:**\n"
                for vuln in web_scan_results['vulnerabilities']:
                    response += f"â€¢ {vuln['name']} - {vuln['severity'].upper()}\n"
                    response += f"  â””â”€ {vuln['description']}\n"
                response += "\n"
            
            response += "**Recommendations:**\n"
            for rec in web_scan_results['recommendations']:
                response += f"â€¢ {rec}\n"
            
            response += "\n"
        
        return response
    
    def _simulate_web_scan(self, url: str) -> Dict[str, Any]:
        """Simulate web application vulnerability scan"""
        return {
            'url': url,
            'scan_time': datetime.now().isoformat(),
            'total_checks': 45,
            'risk_level': 'medium',
            'vulnerabilities': [
                {
                    'name': 'Missing Security Headers',
                    'severity': 'medium',
                    'description': 'Missing X-Frame-Options header'
                },
                {
                    'name': 'Insecure Cookie Configuration',
                    'severity': 'low',
                    'description': 'Cookies not marked as Secure'
                }
            ],
            'recommendations': [
                'Implement proper security headers',
                'Configure secure cookie settings',
                'Enable HTTPS redirect',
                'Implement Content Security Policy'
            ]
        }
    
    def _handle_config_check(self, message: str) -> str:
        """Handle configuration security checks"""
        response = "âš™ï¸ **Configuration Security Assessment**\n\n"
        
        response += "**Security Configuration Checks:**\n"
        response += "â€¢ SSH configuration hardening\n"
        response += "â€¢ Web server security settings\n"
        response += "â€¢ Database security configuration\n"
        response += "â€¢ Firewall rule validation\n"
        response += "â€¢ SSL/TLS configuration\n\n"
        
        response += "**Common Configuration Issues:**\n"
        response += "â€¢ Default credentials in use\n"
        response += "â€¢ Weak encryption algorithms\n"
        response += "â€¢ Unnecessary services running\n"
        response += "â€¢ Excessive user privileges\n"
        response += "â€¢ Missing security patches\n\n"
        
        response += "**Recommendations:**\n"
        response += "â€¢ Follow security hardening guides\n"
        response += "â€¢ Implement least privilege principle\n"
        response += "â€¢ Regular configuration reviews\n"
        response += "â€¢ Automated compliance monitoring\n"
        
        return response
    
    def _handle_patch_assessment(self, message: str) -> str:
        """Handle patch management assessment"""
        response = "ðŸ”„ **Patch Management Assessment**\n\n"
        
        response += "**Patch Status Analysis:**\n"
        response += "â€¢ Operating system patches\n"
        response += "â€¢ Application security updates\n"
        response += "â€¢ Third-party component updates\n"
        response += "â€¢ Critical security patches\n\n"
        
        response += "**Patch Priority Levels:**\n"
        response += "â€¢ **Critical:** Security vulnerabilities with active exploits\n"
        response += "â€¢ **High:** Publicly disclosed vulnerabilities\n"
        response += "â€¢ **Medium:** Important security updates\n"
        response += "â€¢ **Low:** General updates and improvements\n\n"
        
        response += "**Recommendations:**\n"
        response += "â€¢ Establish regular patch cycles\n"
        response += "â€¢ Test patches in staging environment\n"
        response += "â€¢ Monitor vulnerability databases\n"
        response += "â€¢ Implement automated patch management\n"
        
        return response
    
    def _handle_general_vuln_query(self, message: str) -> str:
        """Handle general vulnerability queries"""
        response = "ðŸ”’ **Vulnerability Assessment Services**\n\n"
        
        response += "**Available Scanning Types:**\n"
        response += "â€¢ **Network Scans:** Port scanning, service enumeration\n"
        response += "â€¢ **Web Application Scans:** OWASP Top 10, security headers\n"
        response += "â€¢ **Configuration Checks:** Security hardening validation\n"
        response += "â€¢ **Patch Assessments:** Missing updates and patches\n"
        response += "â€¢ **CVE Lookups:** Vulnerability database queries\n\n"
        
        response += "**Scan Profiles:**\n"
        for profile, info in self.scan_profiles.items():
            response += f"â€¢ **{profile.title()}:** {info['description']}\n"
        
        response += "\n**How to request a scan:**\n"
        response += "â€¢ Provide target IP addresses or hostnames\n"
        response += "â€¢ Specify scan type (network, web, config)\n"
        response += "â€¢ Choose scan profile (basic, comprehensive, stealth)\n"
        response += "â€¢ Ensure you have authorization to scan targets\n"
        
        return response
    
    def execute_task(self, task_type: str, parameters: Dict[str, Any], user_id: str = None) -> str:
        """Execute vulnerability scanning tasks"""
        if task_type == 'network_scan':
            return self._perform_network_scan(parameters)
        elif task_type == 'web_scan':
            return self._perform_web_scan(parameters)
        elif task_type == 'cve_lookup':
            return self._perform_cve_lookup(parameters)
        elif task_type == 'config_check':
            return self._perform_config_check(parameters)
        elif task_type == 'patch_assessment':
            return self._perform_patch_assessment(parameters)
        else:
            return f"Unknown task type: {task_type}"
    
    def _perform_network_scan(self, parameters: Dict[str, Any]) -> str:
        """Perform network vulnerability scan"""
        target = parameters.get('target', '')
        profile = parameters.get('profile', 'basic')
        
        if not target:
            return "No target specified for network scan"
        
        if not self._validate_target(target):
            return f"Invalid or unauthorized target: {target}"
        
        # Simulate scan
        results = self._simulate_network_scan(target)
        return json.dumps(results, indent=2)
    
    def _perform_web_scan(self, parameters: Dict[str, Any]) -> str:
        """Perform web application scan"""
        url = parameters.get('url', '')
        
        if not url:
            return "No URL specified for web scan"
        
        results = self._simulate_web_scan(url)
        return json.dumps(results, indent=2)
    
    def _perform_cve_lookup(self, parameters: Dict[str, Any]) -> str:
        """Perform CVE lookup"""
        cve_id = parameters.get('cve_id', '')
        
        if not cve_id:
            return "No CVE ID specified"
        
        if cve_id in self.cve_database:
            return json.dumps(self.cve_database[cve_id], indent=2)
        else:
            return f"CVE {cve_id} not found in database"
    
    def _perform_config_check(self, parameters: Dict[str, Any]) -> str:
        """Perform configuration security check"""
        # This would perform actual configuration checks
        return "Configuration security check completed"
    
    def _perform_patch_assessment(self, parameters: Dict[str, Any]) -> str:
        """Perform patch management assessment"""
        # This would check for missing patches
        return "Patch assessment completed"
    
    def get_available_tasks(self) -> List[Dict[str, Any]]:
        """Get list of available vulnerability scanning tasks"""
        return [
            {
                'name': 'network_scan',
                'description': 'Perform network vulnerability scan',
                'parameters': ['target', 'profile']
            },
            {
                'name': 'web_scan',
                'description': 'Perform web application vulnerability scan',
                'parameters': ['url']
            },
            {
                'name': 'cve_lookup',
                'description': 'Lookup CVE information',
                'parameters': ['cve_id']
            },
            {
                'name': 'config_check',
                'description': 'Perform configuration security check',
                'parameters': ['target', 'service']
            },
            {
                'name': 'patch_assessment',
                'description': 'Assess patch management status',
                'parameters': ['target', 'scope']
            }
        ]
    
    def _perform_autonomous_tasks(self):
        """Perform autonomous vulnerability scanning tasks"""
        try:
            # Check for new CVEs
            self._check_new_cves()
            
            # Update vulnerability database
            self._update_vuln_database()
            
            # Clean old scan results
            self._cleanup_scan_cache()
            
        except Exception as e:
            self.logger.error(f"Error in autonomous vulnerability tasks: {str(e)}")
    
    def _check_new_cves(self):
        """Check for new CVEs"""
        # This would check for newly published CVEs
        self.logger.debug("Checking for new CVEs")
    
    def _update_vuln_database(self):
        """Update vulnerability database"""
        # This would update the local vulnerability database
        self.logger.debug("Updating vulnerability database")
    
    def _cleanup_scan_cache(self):
        """Clean up old scan results"""
        # Remove old scan results from cache
        current_time = datetime.now()
        expired_keys = []
        
        for key, data in self.scan_cache.items():
            if current_time - data['timestamp'] > timedelta(hours=24):
                expired_keys.append(key)
        
        for key in expired_keys:
            del self.scan_cache[key]
        
        if expired_keys:
            self.logger.debug(f"Cleaned up {len(expired_keys)} old scan results")
    
    def get_scan_summary(self) -> Dict[str, Any]:
        """Get vulnerability scanning summary"""
        return {
            'available_profiles': list(self.scan_profiles.keys()),
            'cve_database_size': len(self.cve_database),
            'cached_scans': len(self.scan_cache),
            'vuln_patterns': len(self.vuln_patterns),
            'last_update': datetime.now().isoformat()
        }